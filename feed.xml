<feed xmlns="http://www.w3.org/2005/Atom"> <id></id><title>Ligengxin's Blog</title><subtitle>This is Ligengxin's Blog, help myself record and share my knowledge. This Blog is a minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-07-14T20:27:49+08:00</updated> <author> <name>Gengxin Li</name> <uri></uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 Gengxin Li </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Azure Automation Account Runbook 入门</title><link href="/posts/use-azure-aotumation-powershell-runbooks/" rel="alternate" type="text/html" title="Azure Automation Account Runbook 入门" /><published>2021-05-13T00:00:00+08:00</published> <updated>2021-05-13T00:00:00+08:00</updated> <id>/posts/use-azure-aotumation-powershell-runbooks/</id> <content src="/posts/use-azure-aotumation-powershell-runbooks/" /> <author> <name>Gengxin Li</name> </author> <category term="Tools" /> <category term="Tutorial" /> <summary>   因为线上的一个Stream Analytics job服务运行不是很稳定(Stream Analytics job 目前是public perview版本),所以需要重启让它重新正常工作.由于这是整个服务的数据流中必不可少的一个部分.如果这里阻塞了将导致下游的服务都不能正常运行,所以势必需在出问题后立刻重启(手动是不可能手动的,能自动化为什么要手动).所以就是为什么需要用到Runbook来自动化重启Stream Analytics job这个服务了. 1.编写Runbook   1.我们首先需要一个建立一个 Automation Account, 然后新建一个连接字符串.以后 PowerShell Runbook 登录授权需要用到 图1-1   2.然后新建一个 PowerShell Runbook,本次重启 Stream Analytics job 的 代码参考 附录... </summary> </entry> <entry><title>使用Dockerfile自定义镜像</title><link href="/posts/learn-use-docker/" rel="alternate" type="text/html" title="使用Dockerfile自定义镜像" /><published>2021-04-11T00:00:00+08:00</published> <updated>2021-04-11T00:00:00+08:00</updated> <id>/posts/learn-use-docker/</id> <content src="/posts/learn-use-docker/" /> <author> <name>Gengxin Li</name> </author> <category term="Tools" /> <category term="Tutorial" /> <summary>   最近准备用Node和TS整点玩具练下手,俗话说工欲善其事必先利其器.所以首先就是整开发环境,然后再搭建CI CD.那么为了做到环境统一,因为觉得Docker比kubernates出来的早应该有更多资源可以参考.所以选择了用Docker.于是踩坑的一天又开始了.下面记录下在构建自己的ubuntu镜像中遇到的问题.附录有构建镜像的实际代码.也可以访问我的github仓库获取最新的代码. 1.构建Ubuntu镜像时候遇到的问题 (1) Build 过程中需要选择时区的问题   这个问题的情况就是你在build Dockerfile的时候会卡住需要你选择时区才能继续(实际上你根本选不了) 这个问题还很好解决只需要加上附录中Dockerfile代码中的第7行和第10行. (2) Build 过程中遇到的网络问题   在Build的时候需要给系统安装一些软件,就需要 apt-get... </summary> </entry> <entry><title>React diff算法分析和理解</title><link href="/posts/how-does-react-diff-algorithm-work/" rel="alternate" type="text/html" title="React diff算法分析和理解" /><published>2021-03-15T00:00:00+08:00</published> <updated>2021-03-15T00:00:00+08:00</updated> <id>/posts/how-does-react-diff-algorithm-work/</id> <content src="/posts/how-does-react-diff-algorithm-work/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary>   距离上次研究 React 工作原理以及有一段时间了,最近又在忙着看小程序方面的东西.忙里偷闲来继续回顾下以前看的 React diff 算法方面的知识. 1. 传统的 diff 算法   传统的 diff 算法的通过循环递归来比对节点的,这里时间复杂度是 O(n^2) 于此同时还需要对 diff 的节点做修改的操作这里的话是 O(n)的时间复杂度,结合到一起就变成了 O(n^3)的时间复杂度.这样的时间复杂度是不能容忍的.因为在你浏览页面的时候如果 1s 内呈现不了内容人就会觉得这个页面卡顿.而 React 中的 diff 算法却能做到只有 O(n)的时间复杂度. 2. React 的 diff 算法   React 的 diff 策略有这3种,附录有这小节涉及的源码 Tree diff   DOM 节点跨层级的移动操作特别少, React 会将这种行为忽略,只对 D... </summary> </entry> <entry><title>使用SQL Server中处理JSON数据</title><link href="/posts/handle-json-in-sql/" rel="alternate" type="text/html" title="使用SQL Server中处理JSON数据" /><published>2021-02-27T00:00:00+08:00</published> <updated>2021-02-27T00:00:00+08:00</updated> <id>/posts/handle-json-in-sql/</id> <content src="/posts/handle-json-in-sql/" /> <author> <name>Gengxin Li</name> </author> <category term="Technology" /> <summary>   这次的任务是需要计算Azure中每个API访问的数量以及访问的方式,为了避免数据库数据冗余,所以就将source这个字段在kusto的查询中处理成了一个JSON.然后在存入到了数据库中.具体需求如下图 1.具体代码 我们首先纵向展开上图的原始数据,可以得到下图的数据 SELECT t1.apiPath, t1.operation, t1.[source], t1.[sourceCount] FROM ( SELECT apiPath, operation, impact.[key] as source, SUM(CAST(ISNULL(impact.[value], 0) AS BIGINT)) AS sourceCount FROM @tempTable1 CROSS APPLY OPENJSON(impact) as impact GROUP BY ap... </summary> </entry> <entry><title>React机制分析总结</title><link href="/posts/how-does-react-work/" rel="alternate" type="text/html" title="React机制分析总结" /><published>2021-02-19T00:00:00+08:00</published> <updated>2021-02-19T00:00:00+08:00</updated> <id>/posts/how-does-react-work/</id> <content src="/posts/how-does-react-work/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary> 1.Virtual DOM   简单说下我对于 Virtual DOM的理解.顾名思义就是虚拟DOM,其实就是在内存中表示的DOM树.那如何在内存中表示DOM树呢,很简单使用一个JSON对象,通过不断在children属性中加入一个个类似的JSON对象,这样就能在内存构建出一棵虚拟的DOM树. { tagName: 'div', // 标签名 properties: { // 属性 style: {} // 样式 }, children: [], // 子节点 key: 1 // 唯一标识 }   再说下我对于JSX的理解,JSX其实只是语法糖,语法糖只是方便我们去写代码,和维护可阅读性.JSX就可以让我们JS代码和React组件嵌套在一起使用.比如下面这个简单的JSX例子,而这背后的逻辑是React的createElement方法在帮我们干活. //... </summary> </entry> </feed>
