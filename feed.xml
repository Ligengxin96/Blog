<feed xmlns="http://www.w3.org/2005/Atom"> <id></id><title>Ligengxin's Blog</title><subtitle>This is Ligengxin's Blog, help myself record and share my knowledge. This Blog is a minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-01-13T23:07:27+08:00</updated> <author> <name>Gengxin Li</name> <uri></uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2022 Gengxin Li </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>重新理解 Node.js 事件循环</title><link href="/posts/node.js-event-loop/" rel="alternate" type="text/html" title="重新理解 Node.js 事件循环" /><published>2022-01-13T00:00:00+08:00</published> <updated>2022-01-13T00:00:00+08:00</updated> <id>/posts/node.js-event-loop/</id> <content src="/posts/node.js-event-loop/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary>    以前我对于 Node.js 的事件循环只有一个模糊概念, 就是 Node.js 执行完毕同步任务后(我理解的同步任务是指,在当前调用栈中执行的代码,而异步任务是指在在当前调用栈中被放置在回调函数里面的代码), 如果同步任务有回调, 那么就丢到事件循环队列中去.同步任务执行完毕后再去执行队列中的回调. 但是最近总是在想一个问题, Node.js 的事件循环有一个问题, 既然是队列,那肯定是遵循先进先出的原则. 那么下面这段代码的输出就应该是 1, 2, 3. 可是最终的输出结果是 2, 3, 1. 今天摸鱼的时候突然想知道为什么,最终我在阮一峰老师的文章下对 Node.js 事件循环有了新的理解. main = () =&amp;gt; { setTimeout(() =&amp;gt; { console.log(1); }, 5 * 1000); setTimeout... </summary> </entry> <entry><title>我的2021年终总结</title><link href="/posts/my-2021-summary/" rel="alternate" type="text/html" title="我的2021年终总结" /><published>2022-01-01T00:00:00+08:00</published> <updated>2022-01-01T00:00:00+08:00</updated> <id>/posts/my-2021-summary/</id> <content src="/posts/my-2021-summary/" /> <author> <name>Gengxin Li</name> </author> <category term="Summary" /> <summary> 1.前言   首先回顾下2020年终总结中的新年展望的完成情况 补充下 Linux 相关知识 (已经掌握常用的 Linux 命令, 现在开发环境已经完全是在 ubuntu 上了) 学会 CI 自动化的一些东西 (熟练使用 Github Action 的 CI/CD) 学会使用Docker (熟悉了常用的 Docker 命令, 并且能使用 Docker 来搭建开发环境) 学习后端知识 (熟悉了 SQL, Node.js, TypeScript. 掌握了 Express, MongoDB, Redis 的使用)   总的来说,我对自己在 2020 新年期望的完成状况打个 80 分的. 没有满分的原因是因为对于后端的数据库, 微服务以及分布式系统相关的知识,我还没有深入的研究. 这其中有一些客观原因和主观原因. 因为我并不知道需要做些什么东西能让我去实践这些东... </summary> </entry> <entry><title>基于 Redis 的分布式锁的实现方案</title><link href="/posts/my-distribution-lock-solution/" rel="alternate" type="text/html" title="基于 Redis 的分布式锁的实现方案" /><published>2021-12-29T00:00:00+08:00</published> <updated>2021-12-29T00:00:00+08:00</updated> <id>/posts/my-distribution-lock-solution/</id> <content src="/posts/my-distribution-lock-solution/" /> <author> <name>Gengxin Li</name> </author> <category term="Technology" /> <summary>   经过上次的调研(这篇blog),最终和 Leader 确定使用 Redis 来实现我们的分布式锁. 实现思路    首先, 我们的 redis 是集群(Cluster)模式,集群里面的 redis 机器都会有一个 backup. 然后当我们的微服务部署后,一般来说分布式锁的名字都是会带上一个数据库中表数据的 id 来保证唯一性,并且使用{}来包裹这个id. 这样在集群模式下 redis 在计算把这个 key 分配给那个节点的时候只会对{}包裹的部分进行计算,并不需要计算整个字符串.可以节约点性能. 举个例子, 我们的一个接口是购买一个商品, 首先我们需要检查库存避免超售.那么我们就需要在业务开始的时候去请求锁. // logger 是 winston loggger 对象 // POD_ID 是 K8S 中每个 pod 的唯一标识 // CONSUMER_NAME 是消费者的... </summary> </entry> <entry><title>Javascript 设计模式与开发实践总结</title><link href="/posts/javascript-design-pattern/" rel="alternate" type="text/html" title="Javascript 设计模式与开发实践总结" /><published>2021-12-18T00:00:00+08:00</published> <updated>2021-12-18T00:00:00+08:00</updated> <id>/posts/javascript-design-pattern/</id> <content src="/posts/javascript-design-pattern/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary>   上班路上看完了《Javascript 设计模式与开发实践》 看完给我个人的感觉就是设计模式的思想是很不错,可以规避很多软件开发和维护的问题.但是因为设计模式太多,全部记住不太现实,所以这里做个笔记把这些设计模式可以解决的问题记录下,当下次遇到什么问题的时候能够想起来可以用那个设计模式来解决.整本书的编程思想可以总体概况为这几个原则. (因为现在希望, 以及目前工作中主要还是使用 Typescript. 所以实例代码也只有 ts 的代码, 并且也只选择了我个人可能会用到的设计模式) 1. 单一职责原则   单一职责原则: 一个对象(方法)只做一件事情即只有一个职责,因为如果有同时负责两个职责,在改动代码的时候容易出现修改了修改只影响A职责的代码而导致B职责的执行出现了问题.而且这样可以把对象(方法)切割成最小粒度,方便复用.较好的实现了这一原则的设计模式有 代理... </summary> </entry> <entry><title>分布式锁/分布式事务的研究报告</title><link href="/posts/distribution-lock-solution-inverstigate/" rel="alternate" type="text/html" title="分布式锁/分布式事务的研究报告" /><published>2021-12-07T00:00:00+08:00</published> <updated>2021-12-07T00:00:00+08:00</updated> <id>/posts/distribution-lock-solution-inverstigate/</id> <content src="/posts/distribution-lock-solution-inverstigate/" /> <author> <name>Gengxin Li</name> </author> <category term="Technology" /> <summary>   成功换了一个后端的工作,开始的第一个任务就是熟悉下分布式锁和分布式事务的实现方案,然后写一份调研报告,这里简单记录下. 1. 分布式锁/分布式事务概念 分布式锁 只要的应用场景是在集群模式的多个相同服务,可能会部署在不同机器上,解决进程间安全问题,防止多进程同时操作一个变量或者数据库.解决的是多进程的并发问题. 分布式事务 解决一个联动操作,比如一个商品的买卖分为: 添加商品到购物车 修改商品库存减1 此时购物车服务和商品库存服务可能部署在两台机器,这时候需要保证对两个服务的操作都全部成功或者全部回退.解决的是组合服务的数据操作的一致性问题.    By the way：node.js 分布式事务并没有很成熟的框架(java 可以使用 Seata),推荐办法是 design first. 把需要事务的微服务聚合成一... </summary> </entry> </feed>
