<feed xmlns="http://www.w3.org/2005/Atom"> <id></id><title>Ligengxin's Blog</title><subtitle>This is Ligengxin's Blog, help myself record and share my knowledge. This Blog is a minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-04-28T21:40:30+08:00</updated> <author> <name>Gengxin Li</name> <uri></uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 Gengxin Li </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>使用Dockerfile自定义镜像</title><link href="/posts/learn-use-docker/" rel="alternate" type="text/html" title="使用Dockerfile自定义镜像" /><published>2021-04-11T00:00:00+08:00</published> <updated>2021-04-11T00:00:00+08:00</updated> <id>/posts/learn-use-docker/</id> <content src="/posts/learn-use-docker/" /> <author> <name>Gengxin Li</name> </author> <category term="Tools" /> <category term="Tutorial" /> <summary>   最近准备用Node和TS整点玩具练下手,俗话说工欲善其事必先利其器.所以首先就是整开发环境,然后再搭建CI CD.那么为了做到环境统一,因为觉得Docker比kubernates出来的早应该有更多资源可以参考.所以选择了用Docker.于是踩坑的一天又开始了.下面记录下在构建自己的ubuntu镜像中遇到的问题.附录有构建镜像的实际代码.也可以访问我的github仓库获取最新的代码. 1.构建Ubuntu镜像时候遇到的问题 (1) Build 过程中需要选择时区的问题   这个问题的情况就是你在build Dockerfile的时候会卡住需要你选择时区才能继续(实际上你根本选不了) 这个问题还很好解决只需要加上附录中Dockerfile代码中的第7行和第10行. (2) Build 过程中遇到的网络问题   在Build的时候需要给系统安装一些软件,就需要 apt-get... </summary> </entry> <entry><title>React diff算法分析和理解</title><link href="/posts/how-does-react-diff-algorithm-work/" rel="alternate" type="text/html" title="React diff算法分析和理解" /><published>2021-03-15T00:00:00+08:00</published> <updated>2021-03-15T00:00:00+08:00</updated> <id>/posts/how-does-react-diff-algorithm-work/</id> <content src="/posts/how-does-react-diff-algorithm-work/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary>   距离上次研究 React 工作原理以及有一段时间了,最近又在忙着看小程序方面的东西.忙里偷闲来继续回顾下以前看的 React diff 算法方面的知识. 1. 传统的 diff 算法   传统的 diff 算法的通过循环递归来比对节点的,这里时间复杂度是 O(n^2) 于此同时还需要对 diff 的节点做修改的操作这里的话是 O(n)的时间复杂度,结合到一起就变成了 O(n^3)的时间复杂度.这样的时间复杂度是不能容忍的.因为在你浏览页面的时候如果 1s 内呈现不了内容人就会觉得这个页面卡顿.而 React 中的 diff 算法却能做到只有 O(n)的时间复杂度. 2. React 的 diff 算法   React 的 diff 策略有这3种,附录有这小节涉及的源码 Tree diff   DOM 节点跨层级的移动操作特别少, React 会将这种行为忽略,只对 D... </summary> </entry> <entry><title>使用SQL Server中处理JSON数据</title><link href="/posts/handle-json-in-sql/" rel="alternate" type="text/html" title="使用SQL Server中处理JSON数据" /><published>2021-02-27T00:00:00+08:00</published> <updated>2021-02-27T00:00:00+08:00</updated> <id>/posts/handle-json-in-sql/</id> <content src="/posts/handle-json-in-sql/" /> <author> <name>Gengxin Li</name> </author> <category term="Technology" /> <summary>   这次的任务是需要计算Azure中每个API访问的数量以及访问的方式,为了避免数据库数据冗余,所以就将source这个字段在kusto的查询中处理成了一个JSON.然后在存入到了数据库中.具体需求如下图 1.具体代码 我们首先纵向展开上图的原始数据,可以得到下图的数据 SELECT t1.apiPath, t1.operation, t1.[source], t1.[sourceCount] FROM ( SELECT apiPath, operation, impact.[key] as source, SUM(CAST(ISNULL(impact.[value], 0) AS BIGINT)) AS sourceCount FROM @tempTable1 CROSS APPLY OPENJSON(impact) as impact GROUP BY ap... </summary> </entry> <entry><title>React机制分析总结</title><link href="/posts/how-does-react-work/" rel="alternate" type="text/html" title="React机制分析总结" /><published>2021-02-19T00:00:00+08:00</published> <updated>2021-02-19T00:00:00+08:00</updated> <id>/posts/how-does-react-work/</id> <content src="/posts/how-does-react-work/" /> <author> <name>Gengxin Li</name> </author> <category term="Learning" /> <summary> 1.Virtual DOM   简单说下我对于 Virtual DOM的理解.顾名思义就是虚拟DOM,其实就是在内存中表示的DOM树.那如何在内存中表示DOM树呢,很简单使用一个JSON对象,通过不断在children属性中加入一个个类似的JSON对象,这样就能在内存构建出一棵虚拟的DOM树. { tagName: 'div', // 标签名 properties: { // 属性 style: {} // 样式 }, children: [], // 子节点 key: 1 // 唯一标识 }   再说下我对于JSX的理解,JSX其实只是语法糖,语法糖只是方便我们去写代码,和维护可阅读性.JSX就可以让我们JS代码和React组件嵌套在一起使用.比如下面这个简单的JSX例子,而这背后的逻辑是React的createElement方法在帮我们干活. //... </summary> </entry> <entry><title>forEach中使用async/await</title><link href="/posts/forEach-async/" rel="alternate" type="text/html" title="forEach中使用async/await" /><published>2021-02-02T00:00:00+08:00</published> <updated>2021-02-02T00:00:00+08:00</updated> <id>/posts/forEach-async/</id> <content src="/posts/forEach-async/" /> <author> <name>Gengxin Li</name> </author> <category term="Technology" /> <summary> 1.问题出现   今天在写Azure Function的时候发现了一个问题,就是为了方便定位问题,于是给下面这段代码添加了log信息 // 大致是需要请求一个接口获取数据然后在把结果发送给另外一个接口 let count = 0; const result = await fetchDataFromDataBase(); result.forEach(async (item) =&amp;gt; { await request(item); count++; }); console.log('发送次数', count);   预期结果就是想看看有没有正确的发送请求的数量.当我调试的时候发现结果很奇怪,理论上来说,result.length和count应该是相等的,但是这段代码表现出来的确是count永远输出的都是0.这就让我很好奇了,这到底是为什么. 2.解决办法   查阅... </summary> </entry> </feed>
